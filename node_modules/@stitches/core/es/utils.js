import { __assign } from "tslib";
import { animation, background, border, borderBottom, borderColor, borderLeft, borderRadius, borderRight, borderStyle, borderTop, borderWidth, boxShadow, font, margin, padding, transition, } from "./shorthand-parser";
export var MAIN_BREAKPOINT_ID = "initial";
export var cssPropToToken = {
    gap: "space",
    gridGap: "space",
    columnGap: "space",
    gridColumnGap: "space",
    rowGap: "space",
    gridRowGap: "space",
    inset: "space",
    insetBlock: "space",
    insetBlockEnd: "space",
    insetBlockStart: "space",
    insetInline: "space",
    insetInlineEnd: "space",
    insetInlineStart: "space",
    margin: "space",
    marginTop: "space",
    marginRight: "space",
    marginBottom: "space",
    marginLeft: "space",
    marginBlock: "space",
    marginBlockEnd: "space",
    marginBlockStart: "space",
    marginInline: "space",
    marginInlineEnd: "space",
    marginInlineStart: "space",
    padding: "space",
    paddingTop: "space",
    paddingRight: "space",
    paddingBottom: "space",
    paddingLeft: "space",
    paddingBlock: "space",
    paddingBlockEnd: "space",
    paddingBlockStart: "space",
    paddingInline: "space",
    paddingInlineEnd: "space",
    paddingInlineStart: "space",
    top: "space",
    right: "space",
    bottom: "space",
    left: "space",
    fontSize: "fontSizes",
    backgroundColor: "colors",
    border: ["", "borderStyles", "colors"],
    borderColor: "colors",
    borderTopColor: "colors",
    borderRightColor: "colors",
    borderBottomColor: "colors",
    borderLeftColor: "colors",
    caretColor: "colors",
    color: "colors",
    columnRuleColor: "colors",
    outlineColor: "colors",
    fill: "colors",
    stroke: "colors",
    fontFamily: "fonts",
    fontWeight: "fontWeights",
    lineHeight: "lineHeights",
    letterSpacing: "letterSpacings",
    blockSize: "sizes",
    minBlockSize: "sizes",
    maxBlockSize: "sizes",
    inlineSize: "sizes",
    minInlineSize: "sizes",
    maxInlineSize: "sizes",
    width: "sizes",
    minWidth: "sizes",
    maxWidth: "sizes",
    height: "sizes",
    minHeight: "sizes",
    maxHeight: "sizes",
    flexBasis: "sizes",
    borderWidth: "borderWidths",
    borderTopWidth: "borderWidths",
    borderLeftWidth: "borderWidths",
    borderRightWidth: "borderWidths",
    borderBottomWidth: "borderWidths",
    borderStyle: "borderStyles",
    borderTopStyle: "borderStyles",
    borderLeftStyle: "borderStyles",
    borderRightStyle: "borderStyles",
    borderBottomStyle: "borderStyles",
    borderRadius: "radii",
    borderTopLeftRadius: "radii",
    borderTopRightRadius: "radii",
    borderBottomRightRadius: "radii",
    borderBottomLeftRadius: "radii",
    boxShadow: "shadows",
    textShadow: "shadows",
    zIndex: "zIndices",
    transition: "transitions",
};
export var tokenTypes = [
    "sizes",
    "colors",
    "space",
    "fontSizes",
    "lineHeights",
    "fontWeights",
    "fonts",
    "borderWidths",
    "radii",
];
var enhanceSheet = function (sheet) {
    return {
        content: sheet.content,
        cssRules: sheet.cssRules,
        insertRule: function (rule) {
            try {
                var newIndex = sheet.insertRule(rule, rule.startsWith("@") ? sheet.cssRules.length : 0);
                return newIndex;
            }
            catch (_a) {
                return -1;
            }
        },
    };
};
export var createSheets = function (env, screens) {
    if (screens === void 0) { screens = {}; }
    var tags = [];
    if (env && env.document) {
        var head_1 = env.document.querySelector("head");
        if (!head_1) {
            throw new Error("There is no HEAD element on this document");
        }
        var styles = Array.from(head_1.querySelectorAll("style"));
        var existingStyles_1 = styles.filter(function (style) {
            return Boolean(style.textContent && style.textContent.startsWith("/* STITCHES"));
        });
        return {
            tags: tags,
            sheets: ["__variables__", MAIN_BREAKPOINT_ID]
                .concat(Object.keys(screens))
                .reduce(function (aggr, key, index) {
                var style = existingStyles_1[index];
                if (!style) {
                    style = env.document.createElement("style");
                    head_1.appendChild(style);
                }
                tags.push(style);
                for (var x = 0; x < document.styleSheets.length; x++) {
                    if (document.styleSheets[x].ownerNode === style) {
                        aggr[key] = enhanceSheet(document.styleSheets[x]);
                        break;
                    }
                }
                return aggr;
            }, {}),
        };
    }
    return {
        tags: tags,
        sheets: ["__variables__", MAIN_BREAKPOINT_ID]
            .concat(Object.keys(screens))
            .reduce(function (aggr, key) {
            aggr[key] = enhanceSheet({
                content: "",
                cssRules: [],
                insertRule: function (content, index) {
                    if (index === void 0) { index = 0; }
                    this.cssRules.splice(index, 0, content);
                },
            });
            return aggr;
        }, {}),
    };
};
export var specificityProps = {
    border: border,
    boxShadow: boxShadow,
    flex: function (tokens, value) {
        if (Array.isArray(value)) {
            if (value.length === 2) {
                return __assign({ flexGrow: value[0] }, (isNaN(value[1])
                    ? { flexBasis: value[1] }
                    : { flexShrink: value[1] }));
            }
            if (value.length === 3) {
                return {
                    flexGrow: value[0],
                    flexShrink: value[1],
                    flexBasis: value[2],
                };
            }
        }
        return isNaN(value)
            ? {
                flexBasis: value,
            }
            : {
                flexGrow: value,
            };
    },
    overflow: function (tokens, value) { return ({
        overflowX: value,
        overflowY: value,
    }); },
    margin: margin,
    padding: padding,
    borderRadius: borderRadius,
    borderColor: borderColor,
    borderStyle: borderStyle,
    borderWidth: borderWidth,
    background: background,
    animation: animation,
    transition: transition,
    font: font,
    borderBottom: borderBottom,
    borderLeft: borderLeft,
    borderTop: borderTop,
    borderRight: borderRight,
};
export var getVendorPrefixAndProps = function (env) {
    var styles = env.getComputedStyle(env.document.documentElement);
    var vendorProps = Array.from(styles).filter(function (prop) { return prop[0] === "-"; });
    // @ts-ignore
    var vendorPrefix = (vendorProps.join("").match(/-(moz|webkit|ms)-/) ||
        (styles.OLink === "" && ["", "o"]))[1];
    return { vendorPrefix: "-" + vendorPrefix + "-", vendorProps: vendorProps };
};
export var hashString = function (str) {
    var hash = 5381;
    var i = str.length;
    while (i) {
        hash = (hash * 33) ^ str.charCodeAt(--i);
    }
    /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
     * integers. Since we want the results to be always positive, convert the
     * signed int to an unsigned by doing an unsigned bitshift. */
    return generateAlphabeticName(hash >>> 0);
};
/**
 * Converts a hash number to alphabetic representation:
 * Copied from:
 * https://github.com/styled-components/styled-components/blob/master/packages/styled-components/src/utils/generateAlphabeticName.js
 */
var AD_REPLACER_R = /(a)(d)/gi;
/* This is the "capacity" of our alphabet i.e. 2x26 for all letters plus their capitalised
 * counterparts */
var charsLength = 52;
/* start at 75 for 'a' until 'z' (25) and then start at 65 for capitalised letters */
var getAlphabeticChar = function (code) {
    return String.fromCharCode(code + (code > 25 ? 39 : 97));
};
/* input a number, usually a hash and convert it to base-52 */
function generateAlphabeticName(code) {
    var name = "";
    var x;
    /* get a char and divide by alphabet-length */
    for (x = Math.abs(code); x > charsLength; x = (x / charsLength) | 0) {
        name = getAlphabeticChar(x % charsLength) + name;
    }
    return (getAlphabeticChar(x % charsLength) + name).replace(AD_REPLACER_R, "$1-$2");
}
//# sourceMappingURL=utils.js.map