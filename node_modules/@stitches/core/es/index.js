import { __spreadArrays } from "tslib";
import { tokenTypes } from "./constants";
import { ATOM, } from "./types";
import { unitlessKeys } from "./unitless";
import { MAIN_BREAKPOINT_ID, createSheets, cssPropToToken, getVendorPrefixAndProps, hashString, specificityProps, } from "./utils";
export * from "./types";
export * from "./css-types";
export * from "./utils";
export var hotReloadingCache = new Map();
var createSelector = function (className, selector) {
    var cssRuleClassName = className ? "." + className : "";
    if (selector && selector.includes("&"))
        return selector.replace(/&/gi, cssRuleClassName);
    if (selector) {
        return "" + cssRuleClassName + selector;
    }
    return cssRuleClassName;
};
/**
 * Resolves a token to its css value in the context of the passed css prop:
 */
var resolveTokens = function (cssProp, value, tokens) {
    var token = cssPropToToken[cssProp];
    var tokenValue;
    if (token) {
        if (Array.isArray(token) && Array.isArray(value)) {
            tokenValue = token.map(function (tokenName, index) {
                return token &&
                    tokens[tokenName] &&
                    tokens[tokenName][value[index]]
                    ? tokens[tokenName][value[index]]
                    : value[index];
            });
        }
        else {
            tokenValue =
                token && tokens[token] && tokens[token][value]
                    ? tokens[token][value]
                    : value;
        }
    }
    else {
        tokenValue = value;
    }
    return tokenValue;
};
/**
 * iterates over a style object keys and values,
 * resolving them to their final form then calls the value callback with the prop, value
 * and the current value nesting path in the style object:
 * - handles utilities
 * - handles specificity props
 * - handles nesting
 * - TODO: also handle the things below once we handle envs differently (to avoid passing a lot of props around):
 * - handles tokens
 * - handles vendor prefixing
 */
var processStyleObject = function (obj, config, valueMiddleware, currentNestingPath, shouldHandleUtils, shouldHandleSpecificityProps) {
    if (currentNestingPath === void 0) { currentNestingPath = []; }
    if (shouldHandleUtils === void 0) { shouldHandleUtils = true; }
    if (shouldHandleSpecificityProps === void 0) { shouldHandleSpecificityProps = true; }
    // key: css prop or override or a selector
    // value is: cssValue, a util, specificity prop, or
    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
        var key = _a[_i];
        var val = obj[key];
        var isUtilProp = shouldHandleUtils && key in config.utils;
        var isSpecificityProp = shouldHandleSpecificityProps && !isUtilProp && key in specificityProps;
        /** Nested styles: */
        if (typeof val === "object" && !isSpecificityProp && !isUtilProp) {
            // Atom value:
            if (val[ATOM]) {
                valueMiddleware(key, val, currentNestingPath);
                continue;
            }
            // handle the value object
            processStyleObject(val, config, valueMiddleware, __spreadArrays(currentNestingPath, [
                key,
            ]));
            continue;
        }
        /** Utils: */
        if (isUtilProp) {
            // Resolve the util from the util function:
            var resolvedUtils = config.utils[key](config)(val);
            processStyleObject(resolvedUtils, config, valueMiddleware, __spreadArrays(currentNestingPath), false);
            continue;
        }
        /** Specificity Props: */
        // shorthand css props or css props that has baked in handling:
        // see specificityProps in ./utils
        if (isSpecificityProp) {
            var resolvedSpecificityProps = specificityProps[key](config.tokens, val);
            processStyleObject(resolvedSpecificityProps, config, valueMiddleware, __spreadArrays(currentNestingPath), false, false);
            continue;
        }
        if (typeof val === "number") {
            // handle unitless numbers:
            valueMiddleware(key, 
            // tslint:disable-next-line: prefer-template
            "" + (unitlessKeys[key] ? val : val + "px"), currentNestingPath);
        }
        else if (val !== undefined) {
            valueMiddleware(key, resolveTokens(key, val, config.tokens), currentNestingPath);
        }
    }
};
/**
 * Resolves a css prop nesting path to a css selector and the breakpoint the css prop is meant to be injected to
 */
var resolveBreakpointAndSelectorAndInlineMedia = function (nestingPath, config) {
    return nestingPath.reduce(function (acc, breakpointOrSelector, i) {
        // utilityFirst selector specific resolution:
        var isOverride = config.utilityFirst && breakpointOrSelector === "override";
        if (isOverride) {
            // any level above 0
            if (i) {
                throw new Error("@stitches/core - You can not override at this level [" + nestingPath
                    .slice(0, i - 1)
                    .join(", ") + ", -> " + breakpointOrSelector + "], only at the top level definition");
            }
            return acc;
        }
        // breakpoints handling:
        if (breakpointOrSelector in config.breakpoints ||
            breakpointOrSelector === MAIN_BREAKPOINT_ID) {
            if (acc.breakpoint !== MAIN_BREAKPOINT_ID) {
                throw new Error("@stitches/core - You are nesting the breakpoint \"" + breakpointOrSelector + "\" into \"" + acc.breakpoint + "\", that makes no sense? :-)");
            }
            acc.breakpoint = breakpointOrSelector;
            return acc;
        }
        if (breakpointOrSelector[0] === "@") {
            acc.inlineMediaQueries.push(breakpointOrSelector);
            return acc;
        }
        // Normal css nesting selector:
        acc.nestingPath =
            acc.nestingPath +
                // If you manually prefix with '&' we remove it for identity consistency
                // only for pseudo selectors and nothing else
                (breakpointOrSelector[0] === "&" && breakpointOrSelector[1] === ":"
                    ? breakpointOrSelector.substr(1)
                    : // pseudo elements/class
                        // don't prepend with a whitespace
                        breakpointOrSelector[0] === ":"
                            ? breakpointOrSelector
                            : // else just nest with a space
                                // tslint:disable-next-line: prefer-template
                                " " + breakpointOrSelector);
        return acc;
    }, {
        breakpoint: MAIN_BREAKPOINT_ID,
        nestingPath: "",
        inlineMediaQueries: [],
    });
};
/**
 * converts an object style css prop to its normal css style object prop and handles prefixing:
 * borderColor => border-color
 */
var hyphenAndVendorPrefixCssProp = function (cssProp, vendorProps, vendorPrefix) {
    var isVendorPrefixed = cssProp[0] === cssProp[0].toUpperCase();
    var cssHyphenProp = cssProp
        .split(/(?=[A-Z])/)
        .map(function (g) { return g.toLowerCase(); })
        .join("-");
    if (isVendorPrefixed) {
        cssHyphenProp = "-" + cssHyphenProp;
    }
    else if (vendorProps.includes("" + vendorPrefix + cssHyphenProp)) {
        cssHyphenProp = "" + vendorPrefix + cssHyphenProp;
    }
    return cssHyphenProp;
};
var toStringCachedAtom = function () {
    return this._className;
};
var toStringCompose = function () {
    var className = this.atoms.map(function (atom) { return atom.toString(); }).join(" ");
    // cache the className on this instance
    // @ts-ignore
    this._className = className;
    // @ts-ignore
    this.toString = toStringCachedAtom;
    return className;
};
var createCssRule = function (breakpoints, atom, className) {
    var cssRule = "";
    if (atom.inlineMediaQueries && atom.inlineMediaQueries.length) {
        var allMediaQueries_1 = "";
        var endBrackets_1 = "";
        atom.inlineMediaQueries.forEach(function (breakpoint) {
            allMediaQueries_1 += breakpoint + "{";
            endBrackets_1 += "}";
        });
        cssRule = "" + allMediaQueries_1 + createSelector(className, atom.selector) + "{" + atom.cssHyphenProp + ":" + atom.value + ";}" + endBrackets_1;
    }
    else {
        cssRule = createSelector(className, atom.selector) + "{" + atom.cssHyphenProp + ":" + atom.value + ";}";
    }
    return atom.breakpoint !== MAIN_BREAKPOINT_ID
        ? breakpoints[atom.breakpoint](cssRule)
        : cssRule;
};
var createToString = function (sheets, breakpoints, cssClassnameProvider, // [className, pseudo]
preInjectedRules) {
    if (breakpoints === void 0) { breakpoints = {}; }
    return function toString() {
        var className = cssClassnameProvider(this);
        var shouldInject = !preInjectedRules.size || !preInjectedRules.has("." + className);
        if (shouldInject) {
            sheets[this.breakpoint].insertRule(createCssRule(breakpoints, this, className));
        }
        // We are switching this atom from IAtom simpler representation
        // 1. delete everything but `id` for specificity check
        // @ts-ignore
        this.cssHyphenProp = this.value = this.pseudo = this.breakpoint = this.inlineMediaQueries = undefined;
        // 2. put on a _className
        this._className = className;
        // 3. switch from this `toString` to a much simpler one
        this.toString = toStringCachedAtom;
        return className;
    };
};
var createServerToString = function (sheets, breakpoints, cssClassnameProvider) {
    if (breakpoints === void 0) { breakpoints = {}; }
    return function toString() {
        var className = cssClassnameProvider(this);
        sheets[this.breakpoint].insertRule(createCssRule(breakpoints, this, className ? "/*X*/" + className + "/*X*/" : ""));
        // We do not clean out the atom here, cause it will be reused
        // to inject multiple times for each request
        // 1. put on a _className
        this._className = className;
        // 2. switch from this `toString` to a much simpler one
        this.toString = toStringCachedAtom;
        return className;
    };
};
var createThemeToString = function (classPrefix, variablesSheet) {
    return function toString() {
        var _this = this;
        var themeClassName = (classPrefix ? classPrefix + "-" : "") + "theme-" + this.name;
        // @ts-ignore
        variablesSheet.insertRule("." + themeClassName + "{" + Object.keys(this.definition).reduce(function (subAggr, tokenKey) {
            // format token to remove special characters
            // https://stackoverflow.com/a/4374890
            var formattedTokenKey = tokenKey.replace(/[^\w\s-]/gi, "");
            // @ts-ignore
            return subAggr + "--colors-" + formattedTokenKey + ":" + _this.definition[tokenKey] + ";";
        }, ""));
        this.toString = function () { return themeClassName; };
        return themeClassName;
    };
};
var createKeyframesToString = function (sheet) {
    return function toString() {
        var _this = this;
        if (this._cssRuleString) {
            sheet.insertRule(this._cssRuleString);
        }
        this.toString = function () { return _this.id; };
        return this.id;
    };
};
var composeIntoMap = function (map, atoms) {
    var i = atoms.length - 1;
    for (; i >= 0; i--) {
        var item = atoms[i];
        // atoms can be undefined, null, false or '' using ternary like
        // expressions with the properties
        if (item && item[ATOM] && "atoms" in item) {
            composeIntoMap(map, item.atoms);
        }
        else if (item && item[ATOM]) {
            if (!map.has(item.id)) {
                map.set(item.id, item);
            }
        }
        else if (item) {
            map.set(item, item);
        }
    }
};
export var createTokens = function (tokens) {
    return tokens;
};
export var createCss = function (_config, env) {
    if (env === void 0) { env = typeof window === "undefined" ? null : window; }
    // pre-checked config to avoid checking these all the time
    // tslint:disable-next-line
    var config = Object.assign({ tokens: {}, utils: {}, breakpoints: {} }, _config);
    // prefill with empty token groups
    tokenTypes.forEach(function (tokenType) { return (config.tokens[tokenType] = config.tokens[tokenType] || {}); });
    var tokens = config.tokens, breakpoints = config.breakpoints;
    var showFriendlyClassnames = typeof config.showFriendlyClassnames === "boolean"
        ? config.showFriendlyClassnames
        : process.env.NODE_ENV === "development";
    var prefix = config.prefix || "";
    var _a = env
        ? getVendorPrefixAndProps(env)
        : { vendorPrefix: "-node-", vendorProps: [] }, vendorPrefix = _a.vendorPrefix, vendorProps = _a.vendorProps;
    if (env && hotReloadingCache.has(prefix)) {
        var instance = hotReloadingCache.get(prefix);
        instance.dispose();
    }
    // pre-compute class prefix
    var classPrefix = prefix
        ? showFriendlyClassnames
            ? prefix + "_"
            : prefix
        : "";
    var cssClassnameProvider = function (atom) {
        var _a;
        if (atom._isGlobal) {
            return "";
        }
        var hash = hashString("" + (atom.breakpoint || "") + atom.cssHyphenProp.replace(/-(moz|webkit|ms)-/, "") + (atom.selector || "") + (((_a = atom.inlineMediaQueries) === null || _a === void 0 ? void 0 : _a.join("")) || "") + atom.value);
        var name = showFriendlyClassnames
            ? "" + (atom.breakpoint ? atom.breakpoint + "_" : "") + atom.cssHyphenProp
                .replace(/-(moz|webkit|ms)-/, "")
                .split("-")
                .map(function (part) { return part[0]; })
                .join("") + "_" + hash
            : "_" + hash;
        return "" + classPrefix + name;
    };
    var _b = createSheets(env, config.breakpoints), tags = _b.tags, sheets = _b.sheets;
    var preInjectedRules = new Set();
    // tslint:disable-next-line
    for (var _i = 0, tags_1 = tags; _i < tags_1.length; _i++) {
        var tag = tags_1[_i];
        ((tag.textContent || "").match(/\/\*\X\*\/.*?\/\*\X\*\//g) || []).forEach(function (rule) {
            // tslint:disable-next-line
            preInjectedRules.add("." + rule.replace(/\/\*X\*\//g, ""));
        });
    }
    var toString = env
        ? createToString(sheets, config.breakpoints, cssClassnameProvider, preInjectedRules)
        : createServerToString(sheets, config.breakpoints, cssClassnameProvider);
    var themeToString = createThemeToString(classPrefix, sheets.__variables__);
    var keyframesToString = createKeyframesToString(sheets[MAIN_BREAKPOINT_ID]);
    var compose = function () {
        var _a;
        var atoms = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            atoms[_i] = arguments[_i];
        }
        var map = new Map();
        composeIntoMap(map, atoms);
        return _a = {
                atoms: Array.from(map.values()),
                toString: toStringCompose
            },
            _a[ATOM] = true,
            _a;
    };
    var createAtom = function (cssProp, value, breakpoint, selectorString, inlineMediaQueries, isGlobal) {
        var _a;
        if (breakpoint === void 0) { breakpoint = MAIN_BREAKPOINT_ID; }
        // generate id used for specificity check
        // two atoms are considered equal in regard to there specificity if the id is equal
        var inlineMediasAsString = inlineMediaQueries
            ? inlineMediaQueries.join("")
            : "";
        var id = cssProp.toLowerCase() +
            selectorString +
            (inlineMediaQueries ? inlineMediaQueries.join("") : "") +
            breakpoint;
        // make a uid accouting for different values
        var uid = id + value;
        // If this was created before return the cached atom
        if (atomCache.has(uid)) {
            // check if this has a breakpoint based media query
            if (inlineMediasAsString.match(/@media.*\((min|max)?.*(width|height).*\)/)) {
                // tslint:disable-next-line
                console.warn("The property \"" + cssProp + "\" with media query " + inlineMediasAsString + " can cause a specificity issue. You should create a breakpoint");
            }
            return atomCache.get(uid);
        }
        // prepare the cssProp
        var cssHyphenProp = hyphenAndVendorPrefixCssProp(cssProp, vendorProps, vendorPrefix);
        // We want certain pseudo selectors to take presedence over other pseudo
        // selectors, so we increase specificity
        if (!(selectorString === null || selectorString === void 0 ? void 0 : selectorString.match("&"))) {
            if (selectorString === null || selectorString === void 0 ? void 0 : selectorString.match(/\:hover/)) {
                selectorString = "&&" + selectorString;
            }
            else if (selectorString === null || selectorString === void 0 ? void 0 : selectorString.match(/\:active/)) {
                selectorString = "&&&" + selectorString;
            }
            else if (selectorString === null || selectorString === void 0 ? void 0 : selectorString.match(/\:focus|\:focus-visible/)) {
                selectorString = "&&&&" + selectorString;
            }
            else if (selectorString === null || selectorString === void 0 ? void 0 : selectorString.match(/\:read-only/)) {
                selectorString = "&&&&&" + selectorString;
            }
            else if (selectorString === null || selectorString === void 0 ? void 0 : selectorString.match(/\:disabled/)) {
                selectorString = "&&&&&&" + selectorString;
            }
        }
        // Create a new atom
        var atom = (_a = {
                id: id,
                cssHyphenProp: cssHyphenProp,
                value: value,
                selector: selectorString,
                inlineMediaQueries: inlineMediaQueries,
                breakpoint: breakpoint,
                toString: toString
            },
            _a[ATOM] = true,
            _a._isGlobal = isGlobal,
            _a);
        // Cache it
        atomCache.set(uid, atom);
        return atom;
    };
    var baseTokens = ":root{";
    // tslint:disable-next-line
    for (var tokenType in tokens) {
        var isNumericScale = tokenType.match(/^(sizes|space|letterSpacings|zIndices)$/);
        // @ts-ignore
        // tslint:disable-next-line
        var scaleTokenKeys = Object.keys(tokens[tokenType]);
        for (var index = 0; index < scaleTokenKeys.length; index++) {
            var token = scaleTokenKeys[index];
            // format token to remove special characters
            // https://stackoverflow.com/a/4374890
            var formattedToken = token.replace(/[^\w\s-]/gi, "");
            var cssVar = "--" + tokenType + "-" + formattedToken;
            // @ts-ignore
            baseTokens += cssVar + ":" + tokens[tokenType][token] + ";";
            // @ts-ignore
            tokens[tokenType][token] = "var(" + cssVar + ")";
            // Add negative tokens
            // tslint:disable-next-line: prefer-template
            var negativeTokenKey = "-" + token;
            // check that it's a numericScale and that the user didn't already set a negative token witht this name
            var isAlreadyANegativeToken = 
            // @ts-ignore
            token[0] === "-" ? !!tokens[tokenType][token.substring(1)] : false;
            if (isNumericScale &&
                // @ts-ignore
                !tokens[tokenType][negativeTokenKey] &&
                !isAlreadyANegativeToken) {
                // @ts-ignore
                tokens[tokenType][negativeTokenKey] = "calc(var(" + cssVar + ") * -1)";
            }
        }
    }
    baseTokens += "}";
    if (!preInjectedRules.has(":root")) {
        sheets.__variables__.insertRule(baseTokens);
    }
    // Keeping track of all atoms for SSR
    var compositionsCache = new Set();
    var atomCache = new Map();
    var keyFramesCache = new Map();
    var themeCache = new Map();
    var cssInstance = (function () {
        var definitions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            definitions[_i] = arguments[_i];
        }
        var args = [];
        var index = 0;
        for (var x = 0; x < definitions.length; x++) {
            if (!definitions[x]) {
                continue;
            }
            if (typeof definitions[x] === "string" || definitions[x][ATOM]) {
                args[index++] = definitions[x];
            }
            else {
                processStyleObject(definitions[x], config, function (prop, value, path) {
                    var _a = resolveBreakpointAndSelectorAndInlineMedia(path, config), nestingPath = _a.nestingPath, breakpoint = _a.breakpoint, inlineMediaQueries = _a.inlineMediaQueries;
                    args[index++] = createAtom(prop, value, breakpoint, nestingPath, inlineMediaQueries);
                });
            }
        }
        // might cause memory leaks when doing css() inside a component
        // but we need this for now to fix SSR
        var composition = compose.apply(void 0, args);
        compositionsCache.add(composition);
        return composition;
    });
    cssInstance.dispose = function () {
        atomCache.clear();
        tags.forEach(function (tag) {
            var _a;
            (_a = tag.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(tag);
        });
    };
    cssInstance._config = function () { return config; };
    cssInstance.theme = function (definition) {
        var _a;
        if (themeCache.has(definition)) {
            return themeCache.get(definition);
        }
        var themeAtom = (_a = {
                // We could here also check if theme has been added from server,
                // though thinking it does not matter... just a simple rule
                name: String(themeCache.size),
                // wrapping the colors in an object so that the structure matches
                // the tokens property in the config
                definition: definition,
                toString: themeToString
            },
            _a[ATOM] = true,
            _a);
        themeCache.set(definition, themeAtom);
        return themeAtom;
    };
    cssInstance.global = function (definitions) {
        processStyleObject(definitions, config, function (prop, value, path) {
            var _a = resolveBreakpointAndSelectorAndInlineMedia(path, config), nestingPath = _a.nestingPath, breakpoint = _a.breakpoint, inlineMediaQueries = _a.inlineMediaQueries;
            if (!nestingPath.length) {
                throw new Error("Global styles need to be nested");
            }
            // Create a global atom and call toString() on it directly to inject it
            // as global atoms don't generate class names of their own
            createAtom(prop, value, breakpoint, nestingPath, inlineMediaQueries, true).toString();
        });
    };
    cssInstance.keyframes = function (definition) {
        var _a;
        var cssRule = "";
        var currentTimeProp = "";
        processStyleObject(definition, config, function (key, value, _a) {
            var timeProp = _a[0];
            if (timeProp !== currentTimeProp) {
                if (cssRule) {
                    cssRule += "}";
                }
                currentTimeProp = timeProp;
                cssRule += timeProp + " {";
            }
            cssRule += hyphenAndVendorPrefixCssProp(key, vendorProps, vendorPrefix) + ": " + resolveTokens(key, value, tokens) + ";";
        });
        var hash = hashString(cssRule);
        // Check if an atom exist with the same hash and return it if so
        var cachedAtom = keyFramesCache.get(hash);
        if (cachedAtom) {
            return cachedAtom;
        }
        // wrap it with the generated keyframes name
        cssRule = "@keyframes " + hash + " {" + cssRule + "}";
        var keyframesAtom = (_a = {
                id: String(hash),
                _cssRuleString: cssRule,
                toString: keyframesToString
            },
            _a[ATOM] = true,
            _a);
        keyFramesCache.set(hash, keyframesAtom);
        return keyframesAtom;
    };
    cssInstance.getStyles = function (cb) {
        // Reset the composition to avoid ssr issues
        compositionsCache.forEach(function (composition) {
            composition.toString = toStringCompose;
        });
        // tslint:disable-next-line
        for (var sheet in sheets) {
            sheets[sheet].cssRules.length = 0;
        }
        if (baseTokens) {
            sheets.__variables__.insertRule(baseTokens);
        }
        // We have to reset our toStrings so that they will now inject again,
        // and still cache is it is being reused
        toString = createServerToString(sheets, config.breakpoints, cssClassnameProvider);
        keyframesToString = createKeyframesToString(sheets[MAIN_BREAKPOINT_ID]);
        themeToString = createThemeToString(classPrefix, sheets.__variables__);
        atomCache.forEach(function (atom) {
            atom.toString = toString;
        });
        keyFramesCache.forEach(function (atom) {
            atom.toString = keyframesToString;
        });
        themeCache.forEach(function (atom) {
            atom.toString = themeToString;
        });
        var result = cb();
        return {
            result: result,
            styles: Object.keys(breakpoints).reduce(function (aggr, key) {
                return aggr.concat("/* STITCHES:" + key + " */\n" + sheets[key].cssRules.join("\n"));
            }, [
                "/* STITCHES:__variables__ */\n" + sheets.__variables__.cssRules.join("\n"),
                "/* STITCHES */\n" + sheets[MAIN_BREAKPOINT_ID].cssRules.join("\n"),
            ]),
        };
    };
    if (env) {
        hotReloadingCache.set(prefix, cssInstance);
    }
    return cssInstance;
};
//# sourceMappingURL=index.js.map