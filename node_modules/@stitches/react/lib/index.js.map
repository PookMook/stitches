{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.tsx"],"names":[],"mappings":"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","sourcesContent":["import {\n  MAIN_BREAKPOINT_ID,\n  TConfig,\n  TCss,\n  TDefaultCss,\n  TMainBreakPoint,\n  createCss,\n  hashString,\n} from \"@stitches/core\";\nimport * as React from \"react\";\n\nlet hasWarnedInlineStyle = false;\n\nexport type TCssProp<T extends TConfig> = TDefaultCss<T> | (string & {});\n\n/**\n * Extracts Variants from an object:\n */\nexport type TExtractVariants<Styles> = Styles extends {\n  variants: infer Variants;\n}\n  ? { [a in keyof Variants]: keyof Variants[a] }\n  : {};\n\n/**\n * Extracts Breakpoint keys from a config\n */\nexport type BreakPointsKeys<\n  Config extends TConfig\n> = keyof Config[\"breakpoints\"];\n\n/**\n * Takes a value and if it's one of the string type representations of a boolean ('true' | 'false')\n * it adds the actual boolean values to it\n */\nexport type CastStringToBoolean<Val> = Val extends \"true\" | \"false\"\n  ? boolean | \"true\" | \"false\"\n  : never;\n/**\n * Takes a variants object and converts it to the correct type information for usage in props\n */\nexport type VariantASProps<Config extends TConfig, VariantsObj> = {\n  [V in keyof VariantsObj]?:\n    | CastStringToBoolean<VariantsObj[V]>\n    | VariantsObj[V]\n    | {\n        [B in BreakPointsKeys<Config> | TMainBreakPoint]?:\n          | CastStringToBoolean<VariantsObj[V]>\n          | VariantsObj[V];\n      };\n};\n\n/**\n * Types for a styled component which contain:\n * 1. First overload which matches when the as prop isn't passed\n * 2. Second overload which matches when the as prop *IS* passed\n * 3. The compoundVariants function typings\n */\nexport interface IStyledComponent<\n  ComponentOrTag extends keyof JSX.IntrinsicElements | React.ComponentType<any>,\n  Variants,\n  Config extends TConfig\n> {\n  /**\n   * First overload without the \"as\" prop\n   */\n  (\n    props: React.ComponentPropsWithRef<ComponentOrTag> & {\n      as?: never;\n      css?: TCssWithBreakpoints<Config>;\n      className?: string;\n      children?: any;\n    } & VariantASProps<Config, Variants>\n  ): any;\n  /**\n   * Second overload * WITH * the \"as\" prop.\n   */\n  <AS extends keyof JSX.IntrinsicElements | React.ComponentType>(\n    props: {\n      as: AS;\n      css?: TCssWithBreakpoints<Config>;\n      className?: string;\n      children?: any;\n    } & VariantASProps<Config, Variants> &\n      React.ComponentPropsWithRef<AS>\n  ): any;\n  /**\n   * Compound Variant typing:\n   */\n  compoundVariant: (\n    compoundVariants: VariantASProps<Config, Variants>,\n    possibleValues: TCssWithBreakpoints<Config>\n  ) => IStyledComponent<ComponentOrTag, Variants, Config>;\n  /**\n   * Default props typing:\n   */\n  defaultProps?: VariantASProps<Config, Variants> & { [k: string]: any };\n  /**\n   * DisplayName typing:\n   */\n  displayName?: string;\n}\n\n/** Typed css with tokens and breakpoints */\nexport type TCssWithBreakpoints<Config extends TConfig> = TCssProp<Config> &\n  { [key in BreakPointsKeys<Config>]?: TCssProp<Config> };\n\n/** The type for the styles in a styled call */\nexport type TComponentStylesObject<\n  Config extends TConfig\n> = TCssWithBreakpoints<Config> & {\n  variants?: {\n    [k: string]: {\n      [s: string]: TCssWithBreakpoints<Config>;\n    };\n  };\n};\n/**\n * Types for styled.button, styled.div, etc..\n */\nexport type TProxyStyledElements<Config extends TConfig> = {\n  [key in keyof JSX.IntrinsicElements]: <\n    BaseAndVariantStyles extends TComponentStylesObject<Config>\n  >(\n    a: BaseAndVariantStyles | TComponentStylesObject<Config>\n  ) => IStyledComponent<key, TExtractVariants<BaseAndVariantStyles>, Config>;\n};\n/**\n * Styled Components creator Type.\n * ie: styled.div(styles) | styled('div', {styles})\n */\nexport type TStyled<Config extends TConfig> = {\n  // tslint:disable-next-line: callable-types\n  <\n    TagOrComponent extends\n      | keyof JSX.IntrinsicElements\n      | React.ComponentType<any>\n      | IStyledComponent<any, any, Config>,\n    BaseAndVariantStyles extends TComponentStylesObject<Config>\n  >(\n    tag: TagOrComponent,\n    baseStyles: BaseAndVariantStyles | TComponentStylesObject<Config>\n  ): TagOrComponent extends IStyledComponent<any, any, Config>\n    ? TagOrComponent\n    : IStyledComponent<\n        TagOrComponent,\n        TExtractVariants<BaseAndVariantStyles>,\n        Config\n      >;\n} & TProxyStyledElements<Config>;\n\nconst createCompoundVariantsMatcher = (breakPoints: any, existingMap?: any) => {\n  const map = new Map();\n  map.set(MAIN_BREAKPOINT_ID, [\n    ...(existingMap?.get(MAIN_BREAKPOINT_ID) || []),\n  ]);\n  Object.keys(breakPoints).forEach((breakpoint) =>\n    map.set(breakpoint, [...(existingMap?.get(breakpoint) || [])])\n  );\n  return map;\n};\n\nexport const createStyled = <Config extends TConfig>(\n  config: Config\n): {\n  css: TCss<Config>;\n  styled: TStyled<Config>;\n} => {\n  const css = createCss(config);\n  const defaultElement = \"div\";\n  const Box = React.forwardRef((props: any, ref: React.Ref<Element>) => {\n    const Element = props.as || defaultElement;\n\n    return React.createElement(Element, {\n      ref,\n      ...props,\n      as: undefined,\n    });\n  });\n\n  let currentAs: string | undefined;\n\n  const configBreakpoints = config.breakpoints || {};\n\n  const styledInstance = (\n    baseAndVariantStyles: any = (cssComposer: any) => cssComposer.compose(),\n    Component: React.ComponentType<any> = Box\n  ) => {\n    let numberOfCompoundVariants = 0;\n    const as = currentAs;\n    const { variants = {}, ...base } = baseAndVariantStyles;\n    const baseStyles: any = css(base);\n    // compound s vars & constants:\n    // keep track of all compound variants:\n    const compoundVariants: any[] = [];\n    // a map that keeps track of the required number of matching s left for each break point:\n    const requiredMatches = createCompoundVariantsMatcher(configBreakpoints);\n    // keep track of the number of available variants\n    const evaluatedVariantMap: Map<\n      string,\n      Map<string, { [key: string]: string }>\n    > = new Map();\n    // store pre evaluated variants\n    const evaluatedCompoundVariants: Map<\n      any,\n      { [key: string]: string }\n    > = new Map();\n\n    // tslint:disable-next-line: forin\n    for (const Name in variants) {\n      const variantMap: Map<string, { [key: string]: string }> = new Map();\n      // tslint:disable-next-line: forin\n      for (const ValueName in variants[Name]) {\n        const evaluatedStyles = evaluateStylesForAllBreakpoints(\n          variants[Name][ValueName],\n          configBreakpoints,\n          css\n        );\n        variantMap.set(ValueName, evaluatedStyles);\n      }\n      evaluatedVariantMap.set(Name, variantMap);\n    }\n\n    const stitchesComponentId = `scid-${hashString(\n      JSON.stringify(baseAndVariantStyles)\n    )}`;\n\n    const StitchesComponent = React.forwardRef(\n      (props: any, ref: React.Ref<Element>) => {\n        // Check the memoCompsition's identity to warn the user\n        // remove in production\n        if (process.env.NODE_ENV === \"development\") {\n          // we're breaking the rules of hooks on purpose as the env will never change\n          // eslint-disable-next-line\n          const memoStyled = React.useMemo(() => props.css, []); // We want this to only eval once\n          if (memoStyled !== props.css && !hasWarnedInlineStyle) {\n            // tslint:disable-next-line\n            console.warn(\n              \"@stitches/react : The css prop should ideally not be dynamic. Define it outside your component using the css composer, or use a memo hook\"\n            );\n            hasWarnedInlineStyle = true;\n          }\n        }\n\n        const compositions = [baseStyles];\n\n        const propsWithoutVariantsAndCssProp: any = {};\n        // clone the compound s matcher\n        const compoundRequiredMatches = createCompoundVariantsMatcher(\n          configBreakpoints,\n          requiredMatches\n        );\n        // keep track of the number of unResolved s so that we could bail early:\n        const numberOfUnResolvedCompoundVariants = {\n          current: numberOfCompoundVariants,\n        };\n        for (const key in props) {\n          // check if the prop is a variant\n          if (key in variants) {\n            const evaluatedVariant = evaluatedVariantMap.get(key);\n            // normalize the value so that we only have to deal with one structure:\n            const keyVal =\n              props[key] && typeof props[key] !== \"object\"\n                ? { [MAIN_BREAKPOINT_ID]: props[key] }\n                : props[key];\n            // tslint:disable-next-line: forin\n            for (const breakpoint in keyVal) {\n              // check if the variant exist for this breakpoint\n              if (\n                keyVal[breakpoint] &&\n                evaluatedVariant &&\n                evaluatedVariant.get(String(keyVal[breakpoint]))\n              ) {\n                compositions.push(\n                  evaluatedVariant.get(String(keyVal[breakpoint]))?.[breakpoint]\n                );\n              }\n              /** Compound variants: */\n              if (numberOfUnResolvedCompoundVariants.current) {\n                compoundVariants.forEach((compoundVariant, i) => {\n                  // if this breakpoint  matches a compound\n                  // eslint-disable-next-line\n                  if (\n                    String(keyVal[breakpoint]) === String(compoundVariant[key])\n                  ) {\n                    compoundRequiredMatches.get(breakpoint)[i]--;\n                  }\n                  // when the required matches reach 0 for any compound ...\n                  // we know we have a matched compoundVariant\n                  if (compoundRequiredMatches.get(breakpoint)[i] === 0) {\n                    numberOfUnResolvedCompoundVariants.current--;\n                    compositions.push(\n                      evaluatedCompoundVariants.get(compoundVariant)?.[\n                        breakpoint\n                      ]\n                    );\n                  }\n                });\n              }\n              /** End compound variants */\n            }\n          } else {\n            propsWithoutVariantsAndCssProp[key] = props[key];\n          }\n        }\n\n        if (propsWithoutVariantsAndCssProp.css) {\n          compositions.push(propsWithoutVariantsAndCssProp.css);\n          propsWithoutVariantsAndCssProp.css = undefined;\n        }\n\n        return React.createElement(Component, {\n          ...propsWithoutVariantsAndCssProp,\n          as: props.as || as,\n          ref,\n          className: css(stitchesComponentId, ...compositions, props.className),\n        });\n      }\n    );\n\n    StitchesComponent.toString = () => `.${stitchesComponentId}`;\n\n    (StitchesComponent as any).compoundVariant = (\n      compundVariantsObject: any,\n      compoundVariantStyles: any\n    ) => {\n      // Update component level variables:\n      numberOfCompoundVariants++;\n      // Each time we add\n      compoundVariants.push(compundVariantsObject);\n      // required matches is a map with breakpoints\n      // each time we add a compound variant, we also push its length to\n      // all of the breakpoints so:\n      // requiredMatches.get(breakpoint)[i] === Object.keys(compoundVariants[i]).length\n      // at render time we clone the requiredMatches map and whenever a prop matches a compound variant we decrement\n      // the required matches for this compound variant at this breakpoint\n      // when the required matches hit 0 we know it's a mtach\n      requiredMatches.forEach((value, key) => {\n        value.push(Object.keys(compundVariantsObject).length);\n      });\n\n      const evaluatedStyles = evaluateStylesForAllBreakpoints(\n        compoundVariantStyles,\n        configBreakpoints,\n        css\n      );\n\n      evaluatedCompoundVariants.set(compundVariantsObject, evaluatedStyles);\n      return StitchesComponent;\n    };\n    return StitchesComponent;\n  };\n\n  // tslint:disable-next-line\n  const styledProxy = new Proxy(() => {}, {\n    get(_, prop) {\n      if (prop === \"Box\") {\n        return Box;\n      }\n      currentAs = String(prop);\n      return styledInstance;\n    },\n    apply(_, __, [Element, styling]) {\n      if (typeof Element === \"string\") {\n        currentAs = Element;\n        return styledInstance(styling);\n      }\n      currentAs = undefined;\n      return styledInstance(styling, Element);\n    },\n  });\n\n  return {\n    styled: styledProxy as any,\n    css,\n  };\n};\nfunction evaluateStylesForAllBreakpoints(\n  styleObject: any,\n  configBreakpoints: any,\n  css: any\n) {\n  const breakpoints: { [key: string]: string } = {\n    [MAIN_BREAKPOINT_ID]: css(styleObject),\n  };\n  if (configBreakpoints) {\n    // tslint:disable-next-line\n    for (const breakpoint in configBreakpoints) {\n      breakpoints[breakpoint] = css({\n        [breakpoint]: styleObject,\n      });\n    }\n  }\n  return breakpoints;\n}\n"]}