import { __assign, __rest, __spreadArrays } from "tslib";
import { MAIN_BREAKPOINT_ID, createCss, hashString, } from "@stitches/core";
import * as React from "react";
var hasWarnedInlineStyle = false;
var createCompoundVariantsMatcher = function (breakPoints, existingMap) {
    var map = new Map();
    map.set(MAIN_BREAKPOINT_ID, __spreadArrays(((existingMap === null || existingMap === void 0 ? void 0 : existingMap.get(MAIN_BREAKPOINT_ID)) || [])));
    Object.keys(breakPoints).forEach(function (breakpoint) {
        return map.set(breakpoint, __spreadArrays(((existingMap === null || existingMap === void 0 ? void 0 : existingMap.get(breakpoint)) || [])));
    });
    return map;
};
export var createStyled = function (config) {
    var css = createCss(config);
    var defaultElement = "div";
    var Box = React.forwardRef(function (props, ref) {
        var Element = props.as || defaultElement;
        return React.createElement(Element, __assign(__assign({ ref: ref }, props), { as: undefined }));
    });
    var currentAs;
    var configBreakpoints = config.breakpoints || {};
    var styledInstance = function (baseAndVariantStyles, Component) {
        if (baseAndVariantStyles === void 0) { baseAndVariantStyles = function (cssComposer) { return cssComposer.compose(); }; }
        if (Component === void 0) { Component = Box; }
        var numberOfCompoundVariants = 0;
        var as = currentAs;
        var _a = baseAndVariantStyles.variants, variants = _a === void 0 ? {} : _a, base = __rest(baseAndVariantStyles, ["variants"]);
        var baseStyles = css(base);
        // compound s vars & constants:
        // keep track of all compound variants:
        var compoundVariants = [];
        // a map that keeps track of the required number of matching s left for each break point:
        var requiredMatches = createCompoundVariantsMatcher(configBreakpoints);
        // keep track of the number of available variants
        var evaluatedVariantMap = new Map();
        // store pre evaluated variants
        var evaluatedCompoundVariants = new Map();
        // tslint:disable-next-line: forin
        for (var Name in variants) {
            var variantMap = new Map();
            // tslint:disable-next-line: forin
            for (var ValueName in variants[Name]) {
                var evaluatedStyles = evaluateStylesForAllBreakpoints(variants[Name][ValueName], configBreakpoints, css);
                variantMap.set(ValueName, evaluatedStyles);
            }
            evaluatedVariantMap.set(Name, variantMap);
        }
        var stitchesComponentId = "scid-" + hashString(JSON.stringify(baseAndVariantStyles));
        var StitchesComponent = React.forwardRef(function (props, ref) {
            var _a;
            // Check the memoCompsition's identity to warn the user
            // remove in production
            if (process.env.NODE_ENV === "development") {
                // we're breaking the rules of hooks on purpose as the env will never change
                // eslint-disable-next-line
                var memoStyled = React.useMemo(function () { return props.css; }, []); // We want this to only eval once
                if (memoStyled !== props.css && !hasWarnedInlineStyle) {
                    // tslint:disable-next-line
                    console.warn("@stitches/react : The css prop should ideally not be dynamic. Define it outside your component using the css composer, or use a memo hook");
                    hasWarnedInlineStyle = true;
                }
            }
            var compositions = [baseStyles];
            var propsWithoutVariantsAndCssProp = {};
            // clone the compound s matcher
            var compoundRequiredMatches = createCompoundVariantsMatcher(configBreakpoints, requiredMatches);
            // keep track of the number of unResolved s so that we could bail early:
            var numberOfUnResolvedCompoundVariants = {
                current: numberOfCompoundVariants,
            };
            var _loop_1 = function (key) {
                var _a;
                // check if the prop is a variant
                if (key in variants) {
                    var evaluatedVariant = evaluatedVariantMap.get(key);
                    // normalize the value so that we only have to deal with one structure:
                    var keyVal_1 = props[key] && typeof props[key] !== "object"
                        ? (_a = {}, _a[MAIN_BREAKPOINT_ID] = props[key], _a) : props[key];
                    var _loop_2 = function (breakpoint) {
                        // check if the variant exist for this breakpoint
                        if (keyVal_1[breakpoint] &&
                            evaluatedVariant &&
                            evaluatedVariant.get(String(keyVal_1[breakpoint]))) {
                            compositions.push((_a = evaluatedVariant.get(String(keyVal_1[breakpoint]))) === null || _a === void 0 ? void 0 : _a[breakpoint]);
                        }
                        /** Compound variants: */
                        if (numberOfUnResolvedCompoundVariants.current) {
                            compoundVariants.forEach(function (compoundVariant, i) {
                                var _a;
                                // if this breakpoint  matches a compound
                                // eslint-disable-next-line
                                if (String(keyVal_1[breakpoint]) === String(compoundVariant[key])) {
                                    compoundRequiredMatches.get(breakpoint)[i]--;
                                }
                                // when the required matches reach 0 for any compound ...
                                // we know we have a matched compoundVariant
                                if (compoundRequiredMatches.get(breakpoint)[i] === 0) {
                                    numberOfUnResolvedCompoundVariants.current--;
                                    compositions.push((_a = evaluatedCompoundVariants.get(compoundVariant)) === null || _a === void 0 ? void 0 : _a[breakpoint]);
                                }
                            });
                        }
                    };
                    // tslint:disable-next-line: forin
                    for (var breakpoint in keyVal_1) {
                        _loop_2(breakpoint);
                    }
                }
                else {
                    propsWithoutVariantsAndCssProp[key] = props[key];
                }
            };
            for (var key in props) {
                _loop_1(key);
            }
            if (propsWithoutVariantsAndCssProp.css) {
                compositions.push(propsWithoutVariantsAndCssProp.css);
                propsWithoutVariantsAndCssProp.css = undefined;
            }
            return React.createElement(Component, __assign(__assign({}, propsWithoutVariantsAndCssProp), { as: props.as || as, ref: ref, className: css.apply(void 0, __spreadArrays([stitchesComponentId], compositions, [props.className])) }));
        });
        StitchesComponent.toString = function () { return "." + stitchesComponentId; };
        StitchesComponent.compoundVariant = function (compundVariantsObject, compoundVariantStyles) {
            // Update component level variables:
            numberOfCompoundVariants++;
            // Each time we add
            compoundVariants.push(compundVariantsObject);
            // required matches is a map with breakpoints
            // each time we add a compound variant, we also push its length to
            // all of the breakpoints so:
            // requiredMatches.get(breakpoint)[i] === Object.keys(compoundVariants[i]).length
            // at render time we clone the requiredMatches map and whenever a prop matches a compound variant we decrement
            // the required matches for this compound variant at this breakpoint
            // when the required matches hit 0 we know it's a mtach
            requiredMatches.forEach(function (value, key) {
                value.push(Object.keys(compundVariantsObject).length);
            });
            var evaluatedStyles = evaluateStylesForAllBreakpoints(compoundVariantStyles, configBreakpoints, css);
            evaluatedCompoundVariants.set(compundVariantsObject, evaluatedStyles);
            return StitchesComponent;
        };
        return StitchesComponent;
    };
    // tslint:disable-next-line
    var styledProxy = new Proxy(function () { }, {
        get: function (_, prop) {
            if (prop === "Box") {
                return Box;
            }
            currentAs = String(prop);
            return styledInstance;
        },
        apply: function (_, __, _a) {
            var Element = _a[0], styling = _a[1];
            if (typeof Element === "string") {
                currentAs = Element;
                return styledInstance(styling);
            }
            currentAs = undefined;
            return styledInstance(styling, Element);
        },
    });
    return {
        styled: styledProxy,
        css: css,
    };
};
function evaluateStylesForAllBreakpoints(styleObject, configBreakpoints, css) {
    var _a, _b;
    var breakpoints = (_a = {},
        _a[MAIN_BREAKPOINT_ID] = css(styleObject),
        _a);
    if (configBreakpoints) {
        // tslint:disable-next-line
        for (var breakpoint in configBreakpoints) {
            breakpoints[breakpoint] = css((_b = {},
                _b[breakpoint] = styleObject,
                _b));
        }
    }
    return breakpoints;
}
//# sourceMappingURL=index.js.map